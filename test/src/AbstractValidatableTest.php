<?php

namespace Wellid;
class TestValidatable extends AbstractValidatable {
    private $value = 'mail@benedict\roe@ser.de';
    
    public function getValue() {
        return $this->value;
    }
    
    public function setValue($value) {
        $this->value = $value;
    }
}
/**
 * Generated by PHPUnit_SkeletonGenerator on 2016-01-28 at 12:06:15.
 */
class AbstractValidatableTest extends \PHPUnit_Framework_TestCase {
    const EXPECT_EXCEPTION = 'x';
    /**
     * @var TestValidatable
     */
    protected $object;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp() {
        $this->object = new TestValidatable();
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown() {
        
    }

    /**
     * @covers Wellid\AbstractValidatable::validateBool
     */
    public function testValidateBool() {
        $this->object->addValidator(new Validator\Email());
        $this->assertFalse($this->object->validateBool());
    }

    /**
     * @covers Wellid\AbstractValidatable::addValidator
     */
    public function testAddValidator() {
        $this->assertEmpty($this->object->getValidators());

        $validator = new Validator\Email();

        $this->assertInstanceOf('Wellid\ValidatorHolderInterface', $this->object->addValidator($validator));

        $this->assertCount(1, $this->object->getValidators());

        $this->assertContainsOnlyInstancesOf(get_class($validator), $this->object->getValidators());
    }

    /**
     * @covers Wellid\AbstractValidatable::addValidators
     */
    public function testAddValidators() {
        $this->assertEmpty($this->object->getValidators());

        $this->assertInstanceOf('Wellid\ValidatorHolderInterface', $this->object->addValidators(new Validator\Boolean(), new Validator\MIME('text/plain'), new Validator\MinLength(3)));

        $this->assertCount(3, $this->object->getValidators());

        $this->assertContainsOnlyInstancesOf('Wellid\Validator\ValidatorInterface', $this->object->getValidators());
    }

/**
     * Dataprovider for testValidateValue
     * 
     * @return array
     */
    public function dataProvider() {
        return array(
            array(false, self::EXPECT_EXCEPTION),
            array(null, self::EXPECT_EXCEPTION),
            array(PHP_EOL, self::EXPECT_EXCEPTION),
            array(14, true),
            array(0.009, true),
            array(-10000, false),
            array('6', self::EXPECT_EXCEPTION),
            array('ABC', self::EXPECT_EXCEPTION),
            array('   ', self::EXPECT_EXCEPTION),
            array('', self::EXPECT_EXCEPTION),
            array(array(), self::EXPECT_EXCEPTION),
            array(new \stdClass(), self::EXPECT_EXCEPTION)
        );
    }

    /**
     * @covers Wellid\ValidatorHolder::validateValue
     * @dataProvider dataProvider
     * @depends testAddValidators
     * @param mixed $value
     * @param mixed $expectation Either true, false or self::EXPECT_EXCEPTION
     */
    public function testValidate($value, $expectation) {
        $this->assertEmpty($this->object->getValidators());

        $this->object->setValue($value);
        $v1 = $this->object->validate();
        $this->assertInstanceOf('Wellid\ValidationResultSet', $v1);
        $this->assertTrue($v1->hasPassed());
        $this->assertNull($v1->firstError());

        $this->object->addValidators(new Validator\FloatingPoint(), new Validator\Min(0));

        try {
            $v2 = $this->object->validate();
        } catch (Exception\DataType $ex) {
            if ($expectation !== self::EXPECT_EXCEPTION) {
                throw $ex;
            } else {
                return;
            }
        }

        $this->assertInstanceOf('Wellid\ValidationResultSet', $v2);
        if ($expectation) {
            $this->assertTrue($v2->hasPassed());
        } else {
            $this->assertFalse($v2->hasPassed());
            $this->assertInstanceOf('Wellid\ValidationResult', $v2->firstError());
        }
    }
    
    /**
     * @covers Wellid\ValidatorHolder::validateValue
     * @dataProvider dataProvider
     * @depends testAddValidators
     * @param mixed $value
     * @param mixed $expectation Either true, false or self::EXPECT_EXCEPTION
     */
    public function testValidateValue($value, $expectation) {
        $this->assertEmpty($this->object->getValidators());

        $v1 = $this->object->validateValue($value);
        $this->assertInstanceOf('Wellid\ValidationResultSet', $v1);
        $this->assertTrue($v1->hasPassed());
        $this->assertNull($v1->firstError());

        $this->object->addValidators(new Validator\FloatingPoint(), new Validator\Min(0));

        try {
            $v2 = $this->object->validateValue($value);
        } catch (Exception\DataType $ex) {
            if ($expectation !== self::EXPECT_EXCEPTION) {
                throw $ex;
            } else {
                return;
            }
        }

        $this->assertInstanceOf('Wellid\ValidationResultSet', $v2);
        if ($expectation) {
            $this->assertTrue($v2->hasPassed());
        } else {
            $this->assertFalse($v2->hasPassed());
            $this->assertInstanceOf('Wellid\ValidationResult', $v2->firstError());
        }
    }

}
