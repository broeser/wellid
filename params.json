{"name":"wellid","tagline":"A set of PHP validators.","body":"# wellid\r\n\r\nwellid is a set of PHP validators and a few loosely coupled components for validation.\r\n\r\n[![Build Status](https://travis-ci.org/broeser/wellid.svg?branch=master)](https://travis-ci.org/broeser/wellid)\r\n[![codecov.io](https://codecov.io/github/broeser/wellid/coverage.svg?branch=master)](https://codecov.io/github/broeser/wellid?branch=master)\r\n[![License](http://img.shields.io/:license-mit-blue.svg)](http://mit-license.org)\r\n[![SemVer 2.0.0](https://img.shields.io/badge/semver-2.0.0-blue.svg)](http://semver.org/spec/v2.0.0.html)\r\n\r\nLatest stable version: 0.3.0\r\n\r\n## Goals\r\n\r\n- wellid should be easy to use and easy to learn\r\n- It is up to you, how much of the wellid-package you use, you can start with\r\n  small building blocks and use bigger concepts later\r\n- Extending wellid with your own Validators should be easy \r\n\r\n## Installation\r\n\r\nwellid works with PHP 5.6 and 7.0.\r\n\r\nThe package can be installed via composer:\r\n\r\n``composer require broeser/wellid``\r\n\r\n## Before you start\r\n\r\n- All examples from this manual can be found in [usage_examples.php](usage_examples.php)\r\n  in the same order as in the manual. If an example uses an additional class,\r\n  that class can be found in the examples/-directory.\r\n- **IMPORTANT NOTE:** Never try to validate raw data! Sanitize your data first, \r\nthen pass it to wellid. Recommended sanitization options are:\r\n  1. Let your framework handle sanitization\r\n  2. Use [Sanitor](https://github.com/broeser/sanitor) (composer require broeser/sanitor)\r\n  3. Use PHP's filter_input() and filter_var() methods\r\n\r\n## Using wellid\r\n\r\n### Simple use case _with validateBool()_\r\n\r\n```PHP\r\n<?php\r\n/*\r\n * The value to validate\r\n */\r\n$value = 'somethingentered';\r\n\r\n/*\r\n * The validator that shall be used to validate it\r\n */\r\n$maxLengthValidator = new Wellid\\Validator\\MaxLength(7);\r\n\r\n/*\r\n * Validate the value and do something in case it is valid:\r\n */\r\nif($maxLengthValidator->validateBool($value)) {\r\n    print('The given value '.$value.' fits our requirements of a maximum length of 7 characters! YAY!'.PHP_EOL);\r\n} else {\r\n    print('The given value '.$value.' is totally invalid. :-('.PHP_EOL);\r\n}\r\n```\r\n\r\nThe simplest usage case is creating a new validator and using the \r\n**validateBool()**-method. It takes the value that shall be validated as parameter\r\nand returns true on success and false on failure.\r\n\r\nThese are the validators supplied with wellid by default:\r\n\r\n - Boolean\r\n - Date\r\n - Email\r\n - Filesize\r\n - FloatingPoint\r\n - IPAddress\r\n - Integer\r\n - MacAddress\r\n - Max\r\n - MaxLength\r\n - MIME\r\n - Min\r\n - MinLength\r\n - Password\r\n - URL\r\n\r\n### Error handling _with validate() and ValidationResult_\r\n\r\nSometimes it is important to know, _why_ validation failed. If you need more than\r\nboolean true/false, you can use the **validate()**-method of a validator of\r\nyour choice to get a **ValidationResult**-object. A ValidationResult includes \r\nan error message and error code if validation fails, you can use **getCode()** and\r\n **getMessage()** to retrieve them:\r\n\r\n```PHP\r\n<?php\r\n/*\r\n * The value to validate\r\n */\r\n$value = 'somethingentered';\r\n\r\n/*\r\n * The validator that shall be used to validate it\r\n */\r\n$maxLengthValidator = new Wellid\\Validator\\MaxLength(7);\r\n\r\n/*\r\n * Validate the value and get a ValidationResult-object\r\n */\r\n$validationResult = $maxLengthValidator->validate($value);\r\n\r\nif($validationResult->hasPassed()) {\r\n    print('The given value '.$value.' fits our requirements of a maximum length of 7 characters! YAY!'.PHP_EOL);\r\n} else {\r\n    print('The given value '.$value.' is totally invalid. :-('.PHP_EOL);\r\n    print('Reason: '.$validationResult->getMessage().' – Error code: '.$validationResult->getCode().PHP_EOL);\r\n}\r\n```\r\n\r\n### ValidationResultSets _– A collection of ValidationResults_\r\n\r\nIf you validate a value with several different validators, or if you validate a\r\nlot of different values you might need a better way of handling the results:\r\n\r\nYou can combine several ValidationResults to form a ValidationResultSet. You can\r\n**add()** a single ValidationResult to a ValidationResultSet or you can combine\r\ntwo ValidationResultSets with **addSet()**\r\n\r\nValidationResultSets can be count()-ed and iterated over with foreach(). \r\n\r\n**hasErrors()** is useful to check if there are any errors\r\nin the ValidationResultSet, its counterpart is called **hasPassed()**. You can \r\nretrieve the **firstError()**-ValidationResult (if there is any), if everything\r\nhas passed the method will return null.\r\n\r\n```PHP\r\n<?php\r\n/*\r\n * The value to validate\r\n */\r\n$value = 'somethingentered';\r\n\r\n/*\r\n * The validator that shall be used to validate it\r\n */\r\n$maxLengthValidator = new Wellid\\Validator\\MaxLength(7);\r\n$minLengthValidator = new Wellid\\Validator\\MinLength(3);\r\n\r\n$validationResultSet = new Wellid\\ValidationResultSet();\r\n$validationResultSet->add($maxLengthValidator->validate($value));\r\n$validationResultSet->add($minLengthValidator->validate($value));\r\n\r\nif($validationResultSet->hasPassed()) {\r\n    print('The given value '.$value.' fits our requirements of a maximum and minimum length! YAY!'.PHP_EOL);\r\n} else {\r\n    print('The given value '.$value.' is totally invalid. :-('.PHP_EOL);\r\n}\r\n```\r\n\r\n\r\n### Validating objects _with ValidatableTrait and ValidatableInterface_\r\n\r\nIf you want to create classes (as opposed to primitive data types) whose instances\r\nare validateable by wellid, just implement the **ValidatableInterface** in your class\r\nand use the **ValidatableTrait**. If you prefer abstract classes instead, (e.g.\r\nif you want to override functionality from ValidatableTrait), extending\r\n**AbstractValidatable** is the way to go. In either case, Make sure to implement\r\n a **getValue()** method to supply the validators with a primitive typed version\r\nof your object's value. For a Money-class, for example, that might be a float.\r\n\r\nYou'll now be able to **addValidators()** to your \r\nobject. You can validate your object with the **validate()** and **validateBool()**\r\nmethods. \r\n\r\nNote that **validate()** returns a ValidationResultSet and not a ValidationResult\r\n(see above).\r\n\r\nThe following example code uses three validators: \r\nThe value shall be a floating point number. It shall be between 0 (zero) and \r\n830.\r\n\r\n```PHP\r\n<?php\r\nclass AccountBalance implements \\Wellid\\ValidatableInterface {\r\n    use \\Wellid\\ValidatableTrait;\r\n\r\n    /**\r\n     * @var float\r\n     */\r\n    protected $value = null;\r\n\r\n    public function __construct() {\r\n        $this->addValidators(new \\Wellid\\Validator\\FloatingPoint(), new \\Wellid\\Validator\\Min(0), new \\Wellid\\Validator\\Max(830));\r\n    }\r\n    \r\n    /**\r\n     * @param float $val\r\n     * @return \\self\r\n     */    \r\n    public static function createFromFloat($val) {\r\n        $newInstance = new self();\r\n        $newInstance->setValue($val);\r\n        return $newInstance;\r\n    }\r\n    \r\n    /**\r\n     * @return float\r\n     */\r\n    public function getValue() {\r\n        return $this->value;\r\n    }\r\n    \r\n    /**\r\n     * @param float $val\r\n     */\r\n    public function setValue($val) {\r\n        $this->value = $val;\r\n    }\r\n}\r\n\r\nforeach(array(57.3, -6) as $v) {\r\n    $yourBalance = WellidUsageExamples\\AccountBalance::createFromFloat($v);\r\n    $result = $yourBalance->validate();\r\n    if($result->hasErrors()) {\r\n        print('Oh dear! Something invalid was used as my account balance!'.PHP_EOL);\r\n        print('Aha, that is why: '.$result->firstError()->getMessage().PHP_EOL);\r\n    }\r\n}\r\n```\r\n\r\n### Caching ValidationResultSets _with CacheableValidatableTrait and CacheableValidatableInterface_\r\n\r\nIf a lot of Validators are used in validating an object, caching might improve\r\nperformance. In the last chapter each call to validate() or validateBool()\r\nstarts validation anew. To add caching functionality use \r\n**CacheableValidatableInterface** instead of ValidatableInterface and \r\n**CacheableValidatableTrait** instead of ValidatableTrait. If you prefer an\r\nabstract class over traits and interfaces, extend **AbstractCacheableValidatable**.\r\nAll cache-related functionality can be found in the \\Wellid\\Cache-namespace.\r\n\r\nLike the cacheless variant, CacheableValidatable has to implement the \r\ngetValue()-method.\r\n\r\nCaching will be performed automatically.\r\n\r\nIf you want to disable caching for a particular instance of \r\nCacheableValidatableInterface, you can call **disableValidationCache()**. This\r\nwill also remove a potentially existing ValidationResultSet from the cache of\r\nthat instance.\r\n\r\nWhile rarely useful, you can also force revalidation without disabling the cache.\r\nClear the current ValidationResultSet with **clearValidationResult()**, then use\r\nvalidate() or validateBool() to get a new ValidationResultSet.\r\n\r\n\r\n### A collection of Validators _– The ValidatorHolder_\r\n\r\nThe way wellid is designed, you can always add validators directly to your data\r\nobjects. However it might become handy to store a collection of validators\r\nseparate from the data objects or even without having data objects.\r\n\r\nYou can use the **ValidatorHolder**-class directly, extend it by your own class,\r\nor you can create a class that implements **ValidatorHolderInterface** and may\r\nuse the **ValidatorHolderTrait** to get some basic functionality.\r\n\r\nAdding validators works the same as on data objects: You\r\ncan use addValidators() or **addValidator()** (for a single validator). Use \r\n**getValidators()** to retrieve an array of all assigned validators.\r\n\r\nTo validate a value with the ValidatorHolder, use the **validateValue()**-method. \r\n\r\nThe AccountBalance-example from above becomes much cleaner and easier to \r\nunderstand. \r\n\r\nExample:\r\n\r\n```PHP\r\n<?php\r\nclass AccountBalanceValidators extends \\Wellid\\ValidatorHolder {\r\n    public function __construct() {\r\n        $this->addValidators(new \\Wellid\\Validator\\FloatingPoint(), new \\Wellid\\Validator\\Min(0), new \\Wellid\\Validator\\Max(830));\r\n    }\r\n}\r\n\r\n$accountBalanceValidators = new \\WellidUsageExamples\\AccountBalanceValidators();\r\nforeach(array(57.3, -6) as $v) {\r\n    $result = $accountBalanceValidators->validateValue($v);\r\n    if($result->hasErrors()) {\r\n        print('Oh dear! Something invalid was used as my account balance!'.PHP_EOL);\r\n        print('Aha, that is why: '.$result->firstError()->getMessage().PHP_EOL);\r\n    }\r\n}\r\n```\r\nOf course you don't have to setup the validators in the constructor in your own \r\nproject, but you can just call addValidator or addValidators from anywhere.\r\n\r\nPlease note, that there is currently no validateBoolValue()-method for\r\nValidatorHolders. If you need the boolean value you can use the syntax\r\n``$validationResultAsBool = $accountBalanceValidators->validateValue($value)->hasPassed();``\r\n\r\nAnother example shows, how to use ValidatorHolders with data objects. (Both \r\nused classes are the same as in the examples above):\r\n```PHP\r\n<?php\r\n/*\r\n * Example 3b: Using the ValidatorHolderTrait & ValidatorHolderInterface with\r\n * data objects\r\n */\r\n$accountBalanceValidators = new \\WellidUsageExamples\\AccountBalanceValidators();\r\nforeach(array(57.3, -6) as $v) {\r\n    $yourBalance = WellidUsageExamples\\AccountBalance::createFromFloat($v);\r\n    $result = $accountBalanceValidators->validateValue($yourBalance->getValue());\r\n    if($result->hasErrors()) {\r\n        print('Oh dear! Something invalid was used as my account balance!'.PHP_EOL);\r\n        print('Aha, that is why: '.$result->firstError()->getMessage().PHP_EOL);\r\n    }\r\n}\r\n```\r\n\r\n### Using wellid with Sanitor _with SanitorBridgeTrait and SanitorBridgeInterface_\r\n\r\n[Sanitor](https://github.com/broeser/sanitor) is a thin wrapper around PHP's \r\nsanitization functions (filter_var(), filter_input(), etc.). \r\nIf you want to use Sanitor to sanitize input or arbitrary\r\nvalues before validating them with wellid, there is a handy piece of code called\r\nthe **SanitorBridgeTrait** just for that.\r\n\r\nRefer to Sanitor's README.md for more information.\r\nThese are the four basic steps necessary to integrate Sanitor and wellid\r\n\r\n1. Install the Sanitor package (composer require broeser/sanitor)\r\n2. Substitute the ValidatableTrait and CacheableValidatableTraits with the \r\n   **SanitorBridgeTrait** in all places.\r\n3. Make sure that those classes implement **SanitorBridgeInterface**\r\n4. Make sure that those classes call $this->setSanitizer(...) somewhere\r\n   before validation (e. g. in the constructor) and set a fitting\r\n   sanitization filter (you can try FILTER_DEFAULT)\r\n\r\nSanitorBridge automatically uses caching. You don't have to clear the cache\r\nwhen setting a new rawValue, this will be done automatically.\r\n\r\n```PHP\r\n<?php\r\nclass SanitorWellidEmailExample implements \\Wellid\\SanitorBridgeInterface, \\Wellid\\ValidatableInterface {\r\n    use \\Wellid\\SanitorBridgeTrait, \\Wellid\\ValidatableTrait;\r\n\r\n    /**\r\n     * Constructor\r\n     * \r\n     * @param \\Sanitor\\Sanitizer $sanitizer\r\n     */\r\n    public function __construct(\\Sanitor\\Sanitizer $sanitizer = null) {\r\n        $this->setSanitizer(is_null($sanitizer)?new \\Sanitor\\Sanitizer(FILTER_SANITIZE_EMAIL):$sanitizer);\r\n        $this->addValidator(new \\Wellid\\Validator\\Email());\r\n    }\r\n}\r\n\r\n$emailValidator = new WellidUsageExamples\\SanitorWellidEmailExample(new \\Sanitor\\Sanitizer(FILTER_SANITIZE_EMAIL));\r\n$emailValidator->setRawValue('mail@benedict\\roeser.de'); // because the value will be sanitized before validation, this will actually pass! More information in the \"65{\"-example below\r\nif($emailValidator->validate()->hasErrors()) {\r\n    print('Why! Oh why! Errors everywhere!'.PHP_EOL);\r\n}\r\n\r\n// values can also be optained from INPUT_GET, INPUT_POST, etc.:\r\n$emailValidator->rawValueFromInput(INPUT_REQUEST, 'email');\r\nif($emailValidator->validate()->hasPassed()) {\r\n    print('Nice, this input has been valid: '.$emailValidator->getValue().PHP_EOL);\r\n}\r\n```\r\n\r\nImagine you are expecting an integer as value, but the user enters `65{` instead.\r\nDepending on your business logic, two different cases are possible:\r\n \r\n 1. Ignore the { and assume 65, continue working with 65. Optionally notify the\r\n    user of this – this makes sense if there is an undo anyway and you don't\r\n    want to annoy your users with error messages.\r\n 2. Return an error message and ask for the value again – this makes sense if\r\n    the user is not expected to notice/fix the mistake, or if valid data is\r\n    more important than user experience\r\n\r\nThe first case is the default setting.\r\n\r\nFor the second case, just add a **SanitorMatch**-Validator to your object before\r\nstarting validation. The SanitorMatch-Validator expects the validatable object \r\nitself as parameter on construction. The Validator uses \r\n\"The given value contains illegal characters\" as error message, if validation\r\nfails.\r\n\r\n```PHP\r\n<?php\r\n$emailValidator->addValidator(new \\Wellid\\Validator\\SanitorMatch($emailValidator));\r\n```\r\n\r\nLuckily there is a shorter way to accomplish the same with the method\r\n**addSanitorMatchValidator()**:\r\n```PHP\r\n<?php\r\n$emailValidator->addSanitorMatchValidator();\r\n```\r\n\r\n### Exceptions\r\n\r\nFeel free to use the Exception-classes supplied with wellid in any validation\r\ncontext you want to.\r\n\r\n - DataFormat\r\n - DataType\r\n - NotFound\r\n - FileNotFound\r\n\r\n## Contributing?\r\n\r\nYes, please!\r\n\r\nSee [CONTRIBUTING.md](https://github.com/broeser/wellid/blob/master/CONTRIBUTING.md) for details and/or open an issue with your questions.\r\n\r\nPlease note that this project is released with a [Contributor Code of Conduct](https://github.com/broeser/wellid/blob/master/CODE_OF_CONDUCT.md). \r\nBy participating in this project you agree to abide by its terms.\r\n\r\n## wellid?\r\n\r\nYes, it is a pun on well and valid.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}